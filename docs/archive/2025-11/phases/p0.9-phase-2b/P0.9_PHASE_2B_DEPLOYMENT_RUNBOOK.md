# ARCHIVED

> **âš ï¸ ARCHIVED DOCUMENTATION**
> This file has been archived on 2025-11-14.
> For current documentation, see [docs/README.md](/docs/README.md)
> Category: P0.9 Phase 2B

---

# P0.9 Phase 2B Deployment Runbook

**Status**: ðŸŸ¢ READY FOR DEPLOYMENT
**Date**: 2025-11-11
**Migration**: `20251111_add_security_audit_logs.sql`
**Deployment Window**: Low-traffic period (recommended: 2-4 AM local time)
**Estimated Duration**: 15 minutes (migration) + 30 minutes (verification) = **45 minutes total**

---

## Pre-Deployment Checklist

### Environment Verification
- [ ] Production database backup completed (< 1 hour old)
- [ ] Backup restoration tested and verified
- [ ] Staging environment has migration applied and verified
- [ ] Docker Desktop running (for local testing)
- [ ] Supabase CLI installed: `npm install -g supabase`
- [ ] Database credentials available (service role key)

### Team Availability
- [ ] On-call engineer available for rollback
- [ ] Database admin available (if separate from on-call)
- [ ] Security team notified (optional, for monitoring setup)
- [ ] PagerDuty silences removed (if applicable)

### Monitoring Preparation
- [ ] Grafana dashboard open (database health)
- [ ] Supabase dashboard open (real-time monitoring)
- [ ] Log aggregation tool ready (DataDog/Splunk)
- [ ] PagerDuty/OpsGenie ready for alerts

---

## Deployment Steps

### Step 1: Pre-Deployment Database Backup (5 minutes)

```bash
# Verify current backup status
supabase db dump --db-url $DATABASE_URL > backup_pre_migration_$(date +%Y%m%d_%H%M%S).sql

# Verify backup file size (should be > 0 bytes)
ls -lh backup_pre_migration_*.sql
```

**Success Criteria**: Backup file created, size > 10 KB

---

### Step 2: Apply Migration to Production (2 minutes)

```bash
# Navigate to project root
cd /Users/mikeyoung/CODING/rebuild-6.0

# Apply migration via Supabase CLI
supabase db push --db-url $PRODUCTION_DATABASE_URL \
  --file supabase/migrations/20251111_add_security_audit_logs.sql

# OR via psql
PGPASSWORD=$DB_PASSWORD psql -h $DB_HOST -U $DB_USER -d $DB_NAME \
  -f supabase/migrations/20251111_add_security_audit_logs.sql
```

**Success Criteria**: No errors in output, migration completes in < 5 seconds

**Expected Output**:
```
CREATE TABLE
CREATE INDEX
CREATE INDEX
CREATE INDEX
CREATE INDEX
CREATE INDEX
ALTER TABLE
CREATE POLICY
COMMENT
COMMENT
COMMENT
COMMENT
COMMENT
```

---

### Step 3: Verify Migration Applied Correctly (5 minutes)

```bash
# Run verification script
PGPASSWORD=$DB_PASSWORD psql -h $DB_HOST -U $DB_USER -d $DB_NAME \
  -f supabase/migrations/20251111_add_security_audit_logs_verification.sql > verification_output.txt

# Check output
cat verification_output.txt
```

**Success Criteria**:
- âœ… Table `security_audit_logs` exists
- âœ… 10 columns with correct types
- âœ… 5 indexes created
- âœ… CHECK constraint on severity column
- âœ… RLS enabled
- âœ… RLS policy `security_audit_service_only` exists

**If Verification Fails**: HALT and proceed to Rollback section

---

### Step 4: Integration Test - Application Insert (10 minutes)

#### Test 1: Successful Insert via Application

Create test file: `server/tests/integration/security-audit-logs-integration.test.ts`

```typescript
import { supabase } from '../src/config/supabase';

describe('security_audit_logs Integration', () => {
  it('should insert security violation to database', async () => {
    const testViolation = {
      event_type: 'TEST_DEPLOYMENT_VERIFICATION',
      user_id: 'test-user-' + Date.now(),
      authenticated_restaurant_id: 'restaurant-a',
      attempted_restaurant_id: 'restaurant-b',
      session_id: 'test-session-123',
      ip_address: '127.0.0.1',
      user_agent: 'Test/1.0',
      severity: 'INFO',
      created_at: new Date().toISOString(),
    };

    const { data, error } = await supabase
      .from('security_audit_logs')
      .insert(testViolation)
      .select();

    expect(error).toBeNull();
    expect(data).toHaveLength(1);
    expect(data[0].event_type).toBe('TEST_DEPLOYMENT_VERIFICATION');

    // Cleanup
    await supabase
      .from('security_audit_logs')
      .delete()
      .eq('event_type', 'TEST_DEPLOYMENT_VERIFICATION');
  });
});
```

**Run Test**:
```bash
cd server
npm test -- security-audit-logs-integration.test.ts
```

**Success Criteria**: Test passes, no database errors

---

#### Test 2: File Fallback Simulation

```typescript
describe('security_audit_logs Fallback', () => {
  it('should fall back to file logging if DB insert fails', async () => {
    // Simulate DB failure by using invalid table name
    const mockSupabase = {
      from: () => ({
        insert: () => Promise.resolve({ error: new Error('DB unavailable') })
      })
    };

    // Test that websocket-server.ts logSecurityViolation handles error
    // and writes to file: /var/log/grow/security_violations.log

    // Verify file logging works
    const logPath = process.env.SECURITY_LOG_PATH || '/var/log/grow/security_violations.log';
    const logExists = fs.existsSync(logPath);

    expect(logExists).toBe(true);

    // Read last line of log file
    const logContent = fs.readFileSync(logPath, 'utf-8');
    const lastLine = logContent.trim().split('\n').pop();
    const logEntry = JSON.parse(lastLine);

    expect(logEntry.type).toBeDefined();
    expect(logEntry.severity).toBe('CRITICAL');
  });
});
```

**Manual Test** (if automated test not feasible):
```bash
# 1. Temporarily break DB connection (stop Supabase container OR revoke service role permissions)
# 2. Trigger a WebSocket security violation (use cross-restaurant access test)
# 3. Verify entry written to /var/log/grow/security_violations.log
# 4. Restore DB connection
# 5. Verify next violation logs to database
```

**Success Criteria**: File logging captures violations when DB unavailable

---

### Step 5: Deploy Application Code (5 minutes)

```bash
# Only if WebSocket security code not yet deployed
git add server/src/voice/websocket-server.ts
git add server/tests/security/voice-multi-tenancy.test.ts
git commit -m "feat(security): implement Phase 2B WebSocket multi-tenancy isolation

- Add restaurant ID validation at WebSocket connection
- Add session creation validation
- Add audio processing validation
- Add security violation logging (DB + file fallback)
- Add defense-in-depth session lookup validation

ðŸ¤– Generated with [Claude Code](https://claude.com/claude-code)

Co-Authored-By: Claude <noreply@anthropic.com>"

# Push to main/production branch
git push origin stabilization-initiative
```

**Success Criteria**: Code pushed, CI/CD pipeline triggered (if applicable)

---

### Step 6: Post-Deployment Verification (10 minutes)

#### Health Check 1: Application Starts Successfully

```bash
# Check application logs for startup errors
# Via Docker
docker logs grow-server --tail 100

# Via PM2
pm2 logs grow-server --lines 100

# Via systemd
journalctl -u grow-server -n 100
```

**Success Criteria**: No errors related to `security_audit_logs` table

---

#### Health Check 2: WebSocket Connections Work

```bash
# Test WebSocket connection with valid JWT
wscat -c "wss://production-domain.com/voice?token=VALID_JWT_TOKEN"

# Expected: Connection accepted, no security violations logged
```

**Success Criteria**: WebSocket connections succeed for valid users

---

#### Health Check 3: Cross-Restaurant Access Blocked

```bash
# Test with user authenticated for Restaurant A trying to access Restaurant B session
# Use test token generator or manual JWT crafting

# Expected:
# - Connection rejected with 403 Forbidden OR session creation blocked
# - Entry created in security_audit_logs table
# - Log entry includes: event_type, user_id, authenticated_restaurant_id, attempted_restaurant_id
```

**Verification Query**:
```sql
SELECT
  event_type,
  user_id,
  authenticated_restaurant_id,
  attempted_restaurant_id,
  severity,
  created_at
FROM security_audit_logs
WHERE created_at > NOW() - INTERVAL '1 hour'
ORDER BY created_at DESC
LIMIT 10;
```

**Success Criteria**: Security violations logged to database

---

#### Health Check 4: Performance Baseline

```bash
# Measure average response time for WebSocket connections
# Before: [BASELINE_MS] ms
# After: [CURRENT_MS] ms
# Delta: Should be < 10ms increase

# Monitor CPU/Memory usage
# Before: [BASELINE_%]
# After: [CURRENT_%]
# Delta: Should be < 5% increase
```

**Success Criteria**: No significant performance degradation

---

### Step 7: Enable Monitoring & Alerts (10 minutes)

#### Alert 1: Security Violation Detection

**Prometheus Query**:
```promql
increase(security_violations_total[1m]) > 0
```

**Alert Configuration** (PagerDuty/OpsGenie):
```yaml
alert: SecurityViolationDetected
expr: increase(security_violations_total[1m]) > 0
for: 0m
severity: critical
annotations:
  summary: "Cross-restaurant access attempt detected"
  description: "User {{ $labels.user_id }} attempted to access {{ $labels.attempted_restaurant }} while authenticated for {{ $labels.authenticated_restaurant }}"
```

---

#### Alert 2: Auth Log DB Fallback

**Prometheus Query**:
```promql
rate(auth_log_fallback_total[15m]) > 0.01
```

**Alert Configuration**:
```yaml
alert: AuthLogDatabaseUnavailable
expr: rate(auth_log_fallback_total[15m]) > 0.01
for: 5m
severity: error
annotations:
  summary: "Auth logging falling back to file"
  description: "Database inserts failing for security_audit_logs table"
```

---

#### Grafana Dashboard

Create dashboard with panels:
1. **Security Violations Over Time** (line chart)
   - Query: `rate(security_violations_total[5m])`
2. **Top Violating Users** (table)
   - Query: `topk(10, sum by (user_id) (security_violations_total))`
3. **Violation Severity Distribution** (pie chart)
   - Query: `sum by (severity) (security_violations_total)`
4. **DB vs File Logging Split** (gauge)
   - Query: `security_violations_db_total / (security_violations_db_total + auth_log_fallback_total)`

**Dashboard JSON**: `grafana/dashboards/phase-2b-security.json` (to be created)

---

### Step 8: Update Log Rotation (5 minutes)

Create logrotate config: `/etc/logrotate.d/grow-security`

```bash
/var/log/grow/security_violations.log {
    daily
    rotate 365
    compress
    delaycompress
    notifempty
    create 0640 grow-app grow-app
    sharedscripts
    postrotate
        systemctl reload grow-server > /dev/null 2>&1 || true
    endscript
}

/var/log/grow/auth_failures.log {
    daily
    rotate 30
    compress
    delaycompress
    notifempty
    create 0640 grow-app grow-app
    sharedscripts
    postrotate
        systemctl reload grow-server > /dev/null 2>&1 || true
    endscript
}
```

**Test logrotate**:
```bash
sudo logrotate -f /etc/logrotate.d/grow-security
ls -lh /var/log/grow/*.log*
```

**Success Criteria**: Rotated log files created

---

## Rollback Procedure

### When to Rollback
- Migration fails to apply
- Verification checks fail
- Application fails to start
- Critical errors in logs
- Performance degradation > 20%

### Rollback Steps

#### Option 1: Revert Migration (if table causes issues)

```bash
# Drop table (safe because it's new, no data loss)
PGPASSWORD=$DB_PASSWORD psql -h $DB_HOST -U $DB_USER -d $DB_NAME <<EOF
DROP TABLE IF EXISTS security_audit_logs CASCADE;
EOF
```

**Risk**: ðŸŸ¢ **ZERO** - Table is new, contains no production data

---

#### Option 2: Keep Table, Revert Application Code

```bash
# Revert to previous commit
git revert HEAD
git push origin stabilization-initiative

# Restart application
pm2 restart grow-server
# OR
systemctl restart grow-server
```

**Risk**: ðŸŸ¢ **LOW** - WebSocket code has file fallback, missing table won't crash app

---

#### Option 3: Full Rollback (both table and code)

```bash
# 1. Revert application code
git revert HEAD
git push origin stabilization-initiative

# 2. Drop table
PGPASSWORD=$DB_PASSWORD psql -h $DB_HOST -U $DB_USER -d $DB_NAME <<EOF
DROP TABLE IF EXISTS security_audit_logs CASCADE;
EOF

# 3. Restart application
systemctl restart grow-server

# 4. Verify application healthy
curl -f http://localhost:3000/health || echo "FAILED"
```

---

## Post-Deployment Monitoring (First 24 Hours)

### Hour 1: Intensive Monitoring
- [ ] Check application logs every 5 minutes
- [ ] Monitor error rate (should be < 0.1%)
- [ ] Verify WebSocket connections stable
- [ ] Check for security violations (legitimate or test traffic)

### Hours 2-4: Active Monitoring
- [ ] Check logs every 15 minutes
- [ ] Verify no performance degradation
- [ ] Confirm audit logs writing to database
- [ ] Validate file fallback NOT being used

### Hours 5-24: Passive Monitoring
- [ ] Check alerts once per hour
- [ ] Review security violation logs (if any)
- [ ] Confirm zero false positives
- [ ] Validate monitoring dashboards accurate

---

## Success Criteria Summary

âœ… **Migration Applied**
- security_audit_logs table exists
- 10 columns, 5 indexes, 1 RLS policy
- CHECK constraint on severity

âœ… **Integration Verified**
- Application can insert to table
- File fallback works when DB fails
- No application errors

âœ… **Monitoring Enabled**
- Alerts configured for security violations
- Grafana dashboard created
- Log rotation configured

âœ… **Performance Acceptable**
- WebSocket latency < +10ms
- CPU/Memory < +5%
- No error rate increase

âœ… **Security Validated**
- Cross-restaurant access blocked
- Violations logged to database
- Audit trail complete

---

## Troubleshooting

### Issue 1: Migration Fails with "relation already exists"

**Cause**: Table already created manually

**Resolution**:
```sql
-- Check if table exists
SELECT * FROM pg_tables WHERE tablename = 'security_audit_logs';

-- If exists, verify schema matches migration
-- If schema incorrect, drop and re-run migration
DROP TABLE security_audit_logs CASCADE;
```

---

### Issue 2: Application Cannot Insert to Table

**Cause**: RLS policy blocking service role

**Resolution**:
```sql
-- Verify RLS policy exists
SELECT * FROM pg_policies WHERE tablename = 'security_audit_logs';

-- If missing, recreate policy
CREATE POLICY security_audit_service_only ON security_audit_logs
  FOR ALL
  USING (auth.role() = 'service_role');
```

---

### Issue 3: File Logging Not Working

**Cause**: Log directory doesn't exist or permissions incorrect

**Resolution**:
```bash
# Create log directory
sudo mkdir -p /var/log/grow

# Set permissions
sudo chown grow-app:grow-app /var/log/grow
sudo chmod 0750 /var/log/grow

# Test write
sudo -u grow-app touch /var/log/grow/security_violations.log
```

---

### Issue 4: Alerts Not Triggering

**Cause**: Metrics not exported by application

**Resolution**:
```typescript
// Add to server/src/metrics.ts (or equivalent)
import { Counter } from 'prom-client';

export const securityViolationsTotal = new Counter({
  name: 'security_violations_total',
  help: 'Total cross-restaurant access attempts',
  labelNames: ['event_type', 'severity']
});

// In websocket-server.ts logSecurityViolation()
securityViolationsTotal.inc({
  event_type: violation.type,
  severity: 'CRITICAL'
});
```

---

## Emergency Contacts

**On-Call Engineer**: PagerDuty rotation
**Database Admin**: [Contact Info]
**Security Team Lead**: [Contact Info]
**Product Owner**: [Contact Info]

**Escalation Path**:
1. On-call engineer (immediate)
2. Database admin (if DB issue)
3. Security team lead (if security concern)
4. Product owner (if business impact)

---

## Documentation Updates Required Post-Deployment

- [ ] Update `P0.9_OPERATIONAL_VERIFICATION_CHECKLIST.md` with completion dates
- [ ] Update `P0.9_PHASE_2B_SIGN_OFF_PACKAGE.md` with deployment timestamp
- [ ] Create incident response runbook for security violations
- [ ] Update architecture diagrams with security_audit_logs table
- [ ] Document monitoring alert thresholds and response procedures

---

**Runbook Version**: 1.0
**Last Updated**: 2025-11-11
**Owner**: Engineering Team
**Approved By**: [Pending Sign-Off]
