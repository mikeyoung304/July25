# PIN & Station Auth Security Audit

**Audit Date:** 2025-11-10
**Scope:** PIN authentication (`pinAuth.ts`) and Station authentication (`stationAuth.ts`)
**Previous Work:** Rate limiting fixed in P0.8 (not re-audited)

---

## Executive Summary

**Overall Security Posture: MEDIUM-HIGH RISK**

The PIN and Station authentication systems demonstrate good security practices in several areas (bcrypt hashing, per-PIN salts, brute force protection, proper token storage), but contain **2 critical vulnerabilities** and several high-priority issues that require immediate attention:

1. **CRITICAL**: Database schema flaw allows only one PIN per user globally (breaks multi-tenancy)
2. **CRITICAL**: Non-cryptographically secure random PIN generation
3. **HIGH**: Timing attack vulnerability in PIN validation loop
4. **HIGH**: Weak default secrets with hardcoded fallbacks in production code
5. **MEDIUM**: Missing CSRF protection on auth endpoints (intentional but risky)

---

## Critical Vulnerabilities (P0)

### Vulnerability 1: Schema Violation - Single PIN Per User Breaks Multi-Tenancy

**Type:** Database Schema Design Flaw / Data Integrity Violation
**Location:** `/Users/mikeyoung/CODING/rebuild-6.0/supabase/migrations/.archive/20250130_auth_tables.sql:30`

**Problem:**
```sql
CREATE TABLE IF NOT EXISTS user_pins (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE UNIQUE,  -- ❌ UNIQUE constraint
  restaurant_id UUID NOT NULL, -- Restaurant-scoped PINs
  ...
);
```

The `UNIQUE` constraint on `user_id` means a user can only have **one PIN globally** across all restaurants. The code expects multi-tenancy (per-restaurant PINs) but the schema enforces single-tenancy.

**Impact:**
- A server working at multiple restaurants can only have ONE PIN
- Second restaurant PIN creation will fail with database constraint violation
- Code comment at line 6-9 of `pinAuth.ts` says "A user can have different PINs for different restaurants" but schema prevents this
- Business logic violation: Multi-tenant system broken for shared employees

**Attack Vector:**
While not directly exploitable by attackers, this creates operational failures and could lead to:
1. PIN reuse across restaurants (security risk)
2. Staff unable to authenticate at second location
3. Inconsistent security policies between locations

**Fix:**
```sql
-- Remove UNIQUE constraint on user_id alone
ALTER TABLE user_pins DROP CONSTRAINT IF EXISTS user_pins_user_id_key;

-- Add composite UNIQUE constraint on (user_id, restaurant_id)
ALTER TABLE user_pins ADD CONSTRAINT user_pins_user_restaurant_unique
  UNIQUE(user_id, restaurant_id);
```

**Test:**
```typescript
// Create PIN for user at restaurant A
await createOrUpdatePin({ userId: 'user-1', restaurantId: 'rest-A', pin: '1234' });

// Should succeed: Create different PIN for same user at restaurant B
await createOrUpdatePin({ userId: 'user-1', restaurantId: 'rest-B', pin: '5678' });

// Verify both PINs exist
const pinsA = await validatePin('1234', 'rest-A');
const pinsB = await validatePin('5678', 'rest-B');
expect(pinsA.isValid).toBe(true);
expect(pinsB.isValid).toBe(true);
```

---

### Vulnerability 2: Insecure Random PIN Generation

**Type:** Cryptographic Weakness
**Location:** `/Users/mikeyoung/CODING/rebuild-6.0/server/src/services/auth/pinAuth.ts:380-395`

**Problem:**
```typescript
export function generateRandomPin(length: number = 4): string {
  let pin = '';
  for (let i = 0; i < length; i++) {
    pin += Math.floor(Math.random() * 10).toString();  // ❌ NOT cryptographically secure
  }
  // ...
}
```

`Math.random()` is **not cryptographically secure** and predictable. An attacker who can observe several generated PINs may predict future PINs using PRNG attacks.

**Impact:**
- Generated PINs are predictable if attacker knows the PRNG state
- Admin-generated temporary PINs for new employees could be guessed
- PIN enumeration becomes easier with predictable patterns

**Attack Vector:**
1. Attacker observes 5-10 PINs generated by system (e.g., during bulk staff onboarding)
2. Attacker analyzes patterns in Math.random() output
3. Attacker predicts next PIN and gains unauthorized access

**Fix:**
```typescript
import crypto from 'crypto';

export function generateRandomPin(length: number = 4): string {
  if (length < PIN_LENGTH_MIN || length > PIN_LENGTH_MAX) {
    length = PIN_LENGTH_MIN;
  }

  let pin = '';
  for (let i = 0; i < length; i++) {
    // Use crypto.randomInt for cryptographically secure random numbers
    pin += crypto.randomInt(0, 10).toString();
  }

  // Ensure it's not too simple
  if (/^(\d)\1+$/.test(pin) || pin === '1234' || pin === '0000') {
    return generateRandomPin(length); // Recursively generate a new one
  }

  return pin;
}
```

**Test:**
```typescript
// Generate 1000 PINs and check for patterns
const pins = new Set();
for (let i = 0; i < 1000; i++) {
  pins.add(generateRandomPin(4));
}

// Should generate diverse PINs (no obvious patterns)
expect(pins.size).toBeGreaterThan(900); // Allow some collisions but not many

// Test that function uses crypto module
const cryptoSpy = vi.spyOn(crypto, 'randomInt');
generateRandomPin(4);
expect(cryptoSpy).toHaveBeenCalled();
```

---

## High Priority Issues (P1)

### Issue 1: Timing Attack in PIN Validation Loop

**Type:** Side-Channel Attack / Timing Attack
**Location:** `/Users/mikeyoung/CODING/rebuild-6.0/server/src/services/auth/pinAuth.ts:196-281`

**Problem:**
```typescript
// Try to find matching PIN
for (const record of pinRecords) {
  // Check if account is locked
  if (record.locked_until) {
    // ...
    continue; // ❌ Early exit reveals locked accounts
  }

  // Verify PIN
  const isMatch = verifyPin(pin, record.pin_hash);  // ❌ Loop exits early on match

  if (isMatch) {
    // Success - return immediately  ❌ Timing leak
    return { isValid: true, ... };
  }
}
```

The validation loop has multiple early exits that leak information through timing:
1. **Locked account skip**: Locked accounts take less time (immediate `continue`)
2. **First match wins**: Loop stops on first match, revealing position in database
3. **No constant-time comparison**: Overall loop time varies based on number of users at restaurant

**Impact:**
- Attacker can determine if an account is locked (faster response)
- Attacker can infer how many users work at restaurant (timing variations)
- With multiple PINs at same restaurant, attacker learns which user's PIN is being tested

**Attack Vector:**
1. Attacker sends 100 PIN attempts with timing measurements
2. Attacker notices some attempts are 50ms faster → those accounts are locked
3. Attacker focuses on non-locked accounts for brute force
4. Attacker measures variance to estimate number of staff members

**Fix:**
```typescript
export async function validatePin(
  pin: string,
  restaurantId: string
): Promise<PinValidationResult> {
  try {
    // ... [input validation] ...

    // Fetch ALL pin records (don't filter locked here)
    const { data: pinRecords, error: pinError } = await supabase
      .from('user_pins')
      .select(`...`)
      .eq('restaurant_id', restaurantId);

    if (pinError || !pinRecords || pinRecords.length === 0) {
      // Add artificial delay to prevent timing leaks
      await new Promise(resolve => setTimeout(resolve, 100));
      return { isValid: false, error: 'Invalid PIN' };
    }

    let validMatch = null;

    // ALWAYS iterate through ALL records (constant-time)
    for (const record of pinRecords) {
      // Check lock status
      const isLocked = record.locked_until && new Date(record.locked_until) > new Date();

      // Verify PIN (always compute, even if locked)
      const isMatch = verifyPin(pin, record.pin_hash);

      // Only accept match if not locked (but don't break loop)
      if (isMatch && !isLocked && !validMatch) {
        validMatch = record;
        // Don't break - continue loop for constant time
      }
    }

    // Process result after full iteration
    if (validMatch) {
      // ... [reset attempts, get role, etc.] ...
      return { isValid: true, ... };
    }

    // Failed - increment all matching PIN attempts (constant time)
    // [Update logic here]

    await new Promise(resolve => setTimeout(resolve, 100)); // Constant delay
    return { isValid: false, error: 'Invalid PIN' };
  } catch (error) {
    // ... [error handling] ...
  }
}
```

**Note:** `bcrypt.compareSync()` itself is timing-safe, but the loop structure leaks timing information.

**Test:**
```typescript
// Measure timing variance
const timings = [];
for (let i = 0; i < 100; i++) {
  const start = Date.now();
  await validatePin('9999', restaurantId);
  timings.push(Date.now() - start);
}

// Variance should be minimal (< 10ms)
const avg = timings.reduce((a, b) => a + b) / timings.length;
const variance = timings.reduce((sum, t) => sum + Math.pow(t - avg, 2), 0) / timings.length;
expect(variance).toBeLessThan(100);
```

---

### Issue 2: Weak Default Secrets in Production Code

**Type:** Configuration Security Weakness
**Location:** `/Users/mikeyoung/CODING/rebuild-6.0/server/src/services/auth/pinAuth.ts:14`
**Location:** `/Users/mikeyoung/CODING/rebuild-6.0/server/src/services/auth/stationAuth.ts:10-12`

**Problem:**
```typescript
// pinAuth.ts
const PIN_PEPPER = process.env['PIN_PEPPER'] || 'default-pepper-change-in-production';

// stationAuth.ts
const STATION_TOKEN_SECRET = process.env['STATION_TOKEN_SECRET'] ||
                             process.env['KIOSK_JWT_SECRET'] ||
                             'station-secret-change-in-production';
const DEVICE_FINGERPRINT_SALT = process.env['DEVICE_FINGERPRINT_SALT'] ||
                                'device-salt-change-in-production';
```

Hardcoded fallback secrets in production code create multiple risks:
1. **Visible in source control**: Defaults are publicly visible in git
2. **Silent failure**: App starts with weak secrets if env vars missing
3. **Developer oversight**: Easy to forget setting env vars in production
4. **Cross-deployment vulnerability**: All deployments with missing env vars use same defaults

**Impact:**
- If env vars not set, ALL deployments use same secrets
- Attacker can crack PINs hashed with known default pepper
- Attacker can forge station tokens with known default secret
- Device fingerprints are predictable with default salt

**Current Mitigation:**
`env.ts` validation (lines 191-203) checks secret length and throws in production if missing, but the fallback strings still exist in code and could be used in misconfigured environments.

**Fix:**
```typescript
// pinAuth.ts
const PIN_PEPPER = process.env['PIN_PEPPER'];
if (!PIN_PEPPER) {
  throw new Error('CRITICAL: PIN_PEPPER environment variable is required for PIN authentication');
}

// stationAuth.ts
const STATION_TOKEN_SECRET = process.env['STATION_TOKEN_SECRET'];
if (!STATION_TOKEN_SECRET) {
  throw new Error('CRITICAL: STATION_TOKEN_SECRET environment variable is required for station authentication');
}

const DEVICE_FINGERPRINT_SALT = process.env['DEVICE_FINGERPRINT_SALT'];
if (!DEVICE_FINGERPRINT_SALT) {
  throw new Error('CRITICAL: DEVICE_FINGERPRINT_SALT environment variable is required for device fingerprinting');
}
```

**Alternative (Defense in Depth):**
Keep env validation in `env.ts` but remove fallback strings entirely:
```typescript
const PIN_PEPPER = process.env['PIN_PEPPER'] || '';
if (!PIN_PEPPER) {
  throw new Error('PIN_PEPPER is required');
}
```

**Test:**
```typescript
// Test fails immediately when env var missing
delete process.env.PIN_PEPPER;
expect(() => require('../../services/auth/pinAuth')).toThrow('PIN_PEPPER');
```

---

### Issue 3: Information Disclosure in Error Messages

**Type:** Information Leakage
**Location:** `/Users/mikeyoung/CODING/rebuild-6.0/server/src/services/auth/pinAuth.ts:200-207`

**Problem:**
```typescript
if (record.locked_until) {
  const lockoutTime = new Date(record.locked_until);
  if (lockoutTime > new Date()) {
    pinLogger.warn('Account locked for PIN attempts', {
      userId: record.user_id,
      lockedUntil: record.locked_until  // ❌ Logged to server (okay)
    });
    continue; // Skip locked accounts
  }
}
```

While logging is appropriate, the **loop behavior reveals locked state** via timing (see Issue 1). Additionally:

```typescript
// auth.routes.ts:137
throw Unauthorized(result.error || 'Invalid PIN');
```

If `result.error` contains specific messages like "Account locked" or "Too many attempts", this leaks information to attackers.

**Impact:**
- Attacker learns which PINs correspond to locked accounts
- Attacker can wait for lockout expiry (15 minutes) then retry
- Account enumeration: Attacker can map PINs to users

**Current State:**
The code returns generic "Invalid PIN" for all failures (line 286), which is good. But timing leaks remain.

**Fix:**
Already addressed in Issue 1 (timing attack fix). Ensure ALL error paths return identical messages:

```typescript
// Always return same error
return {
  isValid: false,
  error: 'Invalid PIN'  // Never reveal lock status, attempts remaining, etc.
};
```

**Test:**
```typescript
// Test locked account returns generic error
const result1 = await validatePin('1234', restaurantId); // Locked account
expect(result1.error).toBe('Invalid PIN');

// Test wrong PIN returns identical error
const result2 = await validatePin('9999', restaurantId); // Wrong PIN
expect(result2.error).toBe('Invalid PIN');

// Errors should be identical
expect(result1).toEqual(result2);
```

---

## Medium Priority Issues (P2)

### Issue 1: Station Token Device Fingerprinting Weakness

**Type:** Session Binding Weakness
**Location:** `/Users/mikeyoung/CODING/rebuild-6.0/server/src/services/auth/stationAuth.ts:46-50`

**Problem:**
```typescript
function generateDeviceFingerprint(ipAddress: string, userAgent: string): string {
  const data = `${ipAddress}:${userAgent}:${DEVICE_FINGERPRINT_SALT}`;
  return crypto.createHash('sha256').update(data).digest('hex');
}
```

Device fingerprint uses only IP + User-Agent:
- **IP can change**: Dynamic IPs, VPN rotation, mobile networks
- **User-Agent easily spoofed**: Attacker can clone User-Agent from legitimate device
- **No additional entropy**: No canvas fingerprint, screen resolution, WebGL, etc.

**Impact:**
- Stolen station token can be used from different device if attacker spoofs User-Agent and uses same network
- Session hijacking easier than it should be
- Device binding provides limited security

**Recommendation:**
This is acceptable for kitchen display stations (static IPs, dedicated devices), but consider:
1. Adding IP subnet check instead of exact match (allows DHCP changes within same network)
2. Logging device fingerprint changes for audit
3. Optional strict mode for high-security environments

**Potential Enhancement:**
```typescript
function generateDeviceFingerprint(
  ipAddress: string,
  userAgent: string,
  options?: { strict?: boolean }
): string {
  // Base fingerprint
  const baseData = `${ipAddress}:${userAgent}:${DEVICE_FINGERPRINT_SALT}`;

  if (options?.strict) {
    // Future: Add more entropy sources
    // - TLS client hello fingerprint
    // - HTTP/2 fingerprint
    // - Request header order
  }

  return crypto.createHash('sha256').update(baseData).digest('hex');
}
```

---

### Issue 2: No PIN Rotation Policy

**Type:** Security Policy Gap
**Location:** N/A (missing feature)

**Problem:**
The system has no mechanism to:
- Require PIN changes after X days
- Prevent PIN reuse (no PIN history)
- Force PIN rotation after suspected compromise
- Notify users of stale PINs

**Impact:**
- PINs may remain unchanged for years
- Compromised PINs stay valid indefinitely
- No compliance with password rotation policies

**Recommendation:**
Add PIN rotation tracking:
```sql
ALTER TABLE user_pins ADD COLUMN last_changed_at TIMESTAMPTZ DEFAULT NOW();
ALTER TABLE user_pins ADD COLUMN must_change BOOLEAN DEFAULT FALSE;
```

Add notification system for:
- PINs older than 90 days
- PINs never changed since creation
- Administrative forced rotation

---

### Issue 3: Station Token Lifetime Too Long

**Type:** Token Lifetime Policy
**Location:** `/Users/mikeyoung/CODING/rebuild-6.0/server/src/services/auth/stationAuth.ts:11`

**Problem:**
```typescript
const STATION_TOKEN_EXPIRY_HOURS = 4;
```

Station tokens valid for 4 hours seems reasonable for kitchen displays, but:
- No automatic refresh mechanism
- Stolen token valid for up to 4 hours
- No activity-based timeout (only expiry-based)

**Impact:**
- Compromised token remains valid even if station is inactive
- 4-hour window for token theft attacks

**Current Mitigation:**
- `last_activity_at` is tracked (line 219-225)
- Tokens can be manually revoked (line 246-273)
- Cleanup function exists (line 355-395)

**Recommendation:**
1. Implement **sliding window expiry**: Extend token if activity within last hour
2. Add **inactivity timeout**: Revoke if no activity for 30 minutes
3. Add **automatic rotation**: Issue new token at 50% lifetime and deprecate old one

---

### Issue 4: Missing Rate Limiting on PIN Reset

**Type:** Missing Rate Limiting
**Location:** `/Users/mikeyoung/CODING/rebuild-6.0/server/src/services/auth/pinAuth.ts:301-323`

**Problem:**
```typescript
export async function resetPinAttempts(userId: string, restaurantId: string): Promise<void> {
  // No rate limiting
  const { error } = await supabase
    .from('user_pins')
    .update({ attempts: 0, locked_until: null })
    .eq('user_id', userId)
    .eq('restaurant_id', restaurantId);
}
```

**Impact:**
- Admin can unlock accounts without throttling
- Potential for abuse if admin credentials compromised
- No audit trail of unlock actions

**Recommendation:**
- Add rate limiting on unlock operations (max 10 unlocks/hour per admin)
- Log all unlock operations to `auth_logs` with admin user ID
- Require manager+ role for unlock (check RBAC)

---

### Issue 5: No CSRF Protection on Auth Endpoints

**Type:** CSRF Vulnerability (Accepted Risk)
**Location:** `/Users/mikeyoung/CODING/rebuild-6.0/server/src/middleware/csrf.ts:28`

**Problem:**
```typescript
const skipPaths = [
  '/api/v1/auth/',  // All auth endpoints - protected by rate limiting
  // ...
];
```

Auth endpoints intentionally skip CSRF protection because:
1. They are REST APIs (not browser forms)
2. Protected by rate limiting (P0.8)
3. Require valid credentials

**Impact:**
- Attacker can trigger login attempts from victim's browser
- Attacker can exhaust rate limits for victim's IP
- Session fixation attacks possible if tokens stored in cookies (currently not the case)

**Current Mitigation:**
- Rate limiting prevents brute force (P0.8)
- Tokens in Authorization headers (not cookies)
- No state-changing operations on GET requests

**Recommendation (Defense in Depth):**
Consider adding CSRF for state-changing operations:
- POST `/api/v1/auth/set-pin` (changes user state)
- POST `/api/v1/auth/revoke-stations` (security-sensitive)

Login/logout can remain CSRF-exempt (industry standard for REST APIs).

---

## Security Best Practices Violations

### 1. bcrypt Work Factor Could Be Higher

**Location:** `/Users/mikeyoung/CODING/rebuild-6.0/server/src/services/auth/pinAuth.ts:55`

```typescript
function generateSalt(): string {
  return bcrypt.genSaltSync(10);  // 10 rounds
}
```

**Issue:**
- bcrypt rounds = 10 is OWASP minimum (2^10 = 1,024 iterations)
- Modern recommendation: 12-14 rounds (4,096-16,384 iterations)
- 4-6 digit PINs are easier to crack than passwords

**Recommendation:**
Increase to 12 rounds for better protection:
```typescript
return bcrypt.genSaltSync(12);
```

**Trade-off:** Slightly slower login (100-200ms vs 50ms), but PINs are short and need stronger hashing.

---

### 2. SQL Injection Protected by Supabase Query Builder

**Status:** ✅ NO VULNERABILITY

All database queries use Supabase's parameterized query builder:
```typescript
.from('user_pins')
.select('...')
.eq('user_id', userId)  // ✅ Parameterized
.eq('restaurant_id', restaurantId)  // ✅ Parameterized
```

No raw SQL strings or concatenation found. **No action needed.**

---

### 3. Proper Input Validation on PIN Format

**Status:** ✅ GOOD

```typescript
function validatePinFormat(pin: string): void {
  // Length check
  if (pin.length < PIN_LENGTH_MIN || pin.length > PIN_LENGTH_MAX) { ... }

  // Digits only
  if (!/^\d+$/.test(pin)) { ... }

  // Prevent common patterns
  if (/^(\d)\1+$/.test(pin)) { ... }
  if (pin === '1234' || pin === '123456' || ...) { ... }
}
```

Comprehensive validation prevents:
- SQL injection (digits only)
- XSS (no special chars)
- Common weak PINs

**Recommendation:** Consider adding:
- Sequential patterns: '1234', '2345', '3456'
- Reverse sequences: '4321', '5432'
- Repeated pairs: '1212', '3434'

---

## Positive Findings

### ✅ Strong Password Hashing

- **bcrypt** used instead of weak algorithms (MD5, SHA1)
- **Per-PIN salt** generated for each PIN (not shared salt)
- **Pepper** adds additional secret layer
- **Salt stored separately** in database (proper design)

**Location:** `pinAuth.ts:38-48, 54-56`

---

### ✅ Brute Force Protection

- **5 attempts max** before lockout
- **15-minute lockout** period
- **Per-account tracking** (not just IP-based)
- **Attempt counter reset** on successful auth

**Location:** `pinAuth.ts:15-16, 251-271`

---

### ✅ Proper Token Storage

Station tokens are:
- **Hashed before storage** (SHA-256 of JWT)
- **Never stored in plaintext**
- **Revocation flag** allows instant invalidation
- **Expiry tracking** with cleanup function

**Location:** `stationAuth.ts:98-111, 178-187`

---

### ✅ Comprehensive Audit Logging

All auth events logged to `auth_logs` table:
- PIN success/failure/lockout
- Station login/logout/revocation
- IP address and User-Agent captured
- Metadata in JSONB for extensibility

**Location:** `pinAuth.ts:356-375`, `stationAuth.ts:400-419`

---

### ✅ Multi-Tenant Isolation

- All queries filtered by `restaurant_id`
- No cross-restaurant PIN validation
- Station tokens scoped to restaurant
- Proper RLS policies in database

**Location:** Throughout both files

---

### ✅ Cryptographically Secure Tokens

Station tokens use:
- **crypto.randomBytes()** for token IDs (not Math.random)
- **JWT with HS256** for signed tokens
- **SHA-256 hashing** for storage
- **Device fingerprint binding**

**Location:** `stationAuth.ts:76, 95, 98`

---

## Recommendations

### Immediate (P0) - Fix Before Production

1. **Fix database schema** - Add composite UNIQUE constraint for multi-tenant PINs
2. **Replace Math.random()** - Use `crypto.randomInt()` for PIN generation
3. **Fix timing attack** - Make PIN validation loop constant-time

### Short-Term (P1) - Within 1 Sprint

4. **Remove hardcoded secrets** - Fail immediately if env vars missing
5. **Increase bcrypt rounds** - Change from 10 to 12 for better PIN protection
6. **Add rate limiting** - Throttle PIN reset operations

### Medium-Term (P2) - Within 1 Quarter

7. **Enhance device fingerprinting** - Add IP subnet matching, log changes
8. **Implement PIN rotation** - Add 90-day rotation policy
9. **Add activity-based timeouts** - Invalidate idle station tokens after 30min
10. **Add CSRF for state-changing auth** - Protect `/set-pin` and `/revoke-stations`

### Monitoring & Alerting

- **Alert on suspicious patterns**: Multiple PIN lockouts from same IP
- **Alert on token theft**: Station token used from different device fingerprint
- **Alert on brute force**: >50 failed PIN attempts across all users at restaurant
- **Daily report**: Number of locked accounts, token revocations, PIN resets

---

## Testing Checklist

### Security Tests to Add

```typescript
// 1. Multi-tenant PIN test
describe('PIN Multi-Tenancy', () => {
  it('should allow same user different PINs at different restaurants', async () => {
    await createOrUpdatePin({ userId: 'user-1', restaurantId: 'rest-A', pin: '1234' });
    await createOrUpdatePin({ userId: 'user-1', restaurantId: 'rest-B', pin: '5678' });

    const resultA = await validatePin('1234', 'rest-A');
    const resultB = await validatePin('5678', 'rest-B');

    expect(resultA.isValid).toBe(true);
    expect(resultB.isValid).toBe(true);
  });
});

// 2. Timing attack test
describe('Timing Attack Resistance', () => {
  it('should have consistent response times regardless of PIN validity', async () => {
    const timings = [];
    for (let i = 0; i < 100; i++) {
      const start = performance.now();
      await validatePin(Math.random().toString(), restaurantId);
      timings.push(performance.now() - start);
    }

    const variance = calculateVariance(timings);
    expect(variance).toBeLessThan(100); // < 100ms variance
  });
});

// 3. Cryptographic PIN generation test
describe('PIN Generation Security', () => {
  it('should use crypto.randomInt instead of Math.random', () => {
    const cryptoSpy = vi.spyOn(crypto, 'randomInt');
    generateRandomPin(4);
    expect(cryptoSpy).toHaveBeenCalled();
  });

  it('should generate diverse PINs', () => {
    const pins = new Set();
    for (let i = 0; i < 1000; i++) {
      pins.add(generateRandomPin(4));
    }
    expect(pins.size).toBeGreaterThan(900);
  });
});

// 4. Env validation test
describe('Environment Security', () => {
  it('should fail when PIN_PEPPER is missing', () => {
    delete process.env.PIN_PEPPER;
    expect(() => require('../services/auth/pinAuth')).toThrow();
  });

  it('should fail when STATION_TOKEN_SECRET is missing', () => {
    delete process.env.STATION_TOKEN_SECRET;
    expect(() => require('../services/auth/stationAuth')).toThrow();
  });
});
```

---

## Compliance Notes

### OWASP Top 10 (2021)

- ✅ **A02: Cryptographic Failures** - bcrypt + pepper used
- ⚠️ **A03: Injection** - Supabase prevents SQL injection, but see timing attacks
- ✅ **A05: Security Misconfiguration** - Env validation in place
- ⚠️ **A07: Auth Failures** - Rate limiting good, but timing leaks exist

### PCI DSS (if applicable)

- ⚠️ **Req 8.2.3**: Passwords/PINs must be strong → Add sequential pattern checks
- ⚠️ **Req 8.2.4**: Change passwords every 90 days → Add PIN rotation
- ✅ **Req 8.2.5**: Don't reuse last 4 passwords → Need PIN history table

---

## Conclusion

The PIN and Station authentication systems are **generally well-designed** with strong cryptographic foundations (bcrypt, proper salts, secure token generation). However, **two critical issues must be fixed immediately**:

1. Database schema bug preventing multi-tenant PINs
2. Non-cryptographic random PIN generation

The timing attack vulnerability should be addressed as a high priority to prevent information leakage.

Overall, with the P0 and P1 fixes applied, the authentication system will meet industry security standards for shared-device authentication in restaurant environments.

---

**Auditor Notes:**
- Rate limiting implementation (P0.8) was not re-audited as requested
- JWT authentication for managers/owners (Agent 2 scope) was not audited
- WebSocket authentication (Agent 5 scope) was not audited
- Focus maintained exclusively on PIN and Station auth per mission briefing
