#!/usr/bin/env node
import { exec } from 'child_process';
import { promisify } from 'util';
import * as fs from 'fs/promises';
import * as path from 'path';

const execAsync = promisify(exec);

interface AnalysisResult {
  timestamp: string;
  projectStats: {
    totalFiles: number;
    totalLines: number;
    languages: Record<string, { files: number; lines: number }>;
  };
  testCoverage?: {
    statements: number;
    branches: number;
    functions: number;
    lines: number;
  };
  lintResults: {
    errors: number;
    warnings: number;
  };
  dependencies: {
    total: number;
    outdated: number;
  };
}

async function runCommand(cmd: string): Promise<string> {
  try {
    const { stdout } = await execAsync(cmd);
    return stdout.trim();
  } catch (error) {
    console.error(`Error running command: ${cmd}`, error);
    return '';
  }
}

async function getProjectStats(): Promise<AnalysisResult['projectStats']> {
  const extensions = ['ts', 'tsx', 'js', 'jsx'];
  const stats: AnalysisResult['projectStats'] = {
    totalFiles: 0,
    totalLines: 0,
    languages: {},
  };

  for (const ext of extensions) {
    const files = await runCommand(`find . -name "*.${ext}" -not -path "./node_modules/*" -not -path "./dist/*" | wc -l`);
    const lines = await runCommand(`find . -name "*.${ext}" -not -path "./node_modules/*" -not -path "./dist/*" -exec wc -l {} + | tail -1 | awk '{print $1}'`);
    
    const fileCount = parseInt(files) || 0;
    const lineCount = parseInt(lines) || 0;
    
    if (fileCount > 0) {
      stats.languages[ext] = { files: fileCount, lines: lineCount };
      stats.totalFiles += fileCount;
      stats.totalLines += lineCount;
    }
  }

  return stats;
}

async function getLintResults(): Promise<AnalysisResult['lintResults']> {
  const eslintOutput = await runCommand('npm run lint 2>&1 || true');
  const errorMatch = eslintOutput.match(/(\d+) errors?/);
  const warningMatch = eslintOutput.match(/(\d+) warnings?/);
  
  return {
    errors: errorMatch ? parseInt(errorMatch[1]) : 0,
    warnings: warningMatch ? parseInt(warningMatch[1]) : 0,
  };
}

async function getDependencyInfo(): Promise<AnalysisResult['dependencies']> {
  const packageJson = JSON.parse(await fs.readFile('package.json', 'utf-8'));
  const deps = Object.keys(packageJson.dependencies || {}).length;
  const devDeps = Object.keys(packageJson.devDependencies || {}).length;
  
  // Check for outdated packages (simplified)
  const outdatedOutput = await runCommand('npm outdated --json || true');
  let outdated = 0;
  try {
    const outdatedData = JSON.parse(outdatedOutput || '{}');
    outdated = Object.keys(outdatedData).length;
  } catch {}
  
  return {
    total: deps + devDeps,
    outdated,
  };
}

async function generateReport(): Promise<void> {
  
  const result: AnalysisResult = {
    timestamp: new Date().toISOString(),
    projectStats: await getProjectStats(),
    lintResults: await getLintResults(),
    dependencies: await getDependencyInfo(),
  };
  
  // Generate markdown report
  const report = `# Code Analysis Report

Generated: ${new Date().toLocaleString()}

## Project Statistics

- **Total Files**: ${result.projectStats.totalFiles}
- **Total Lines**: ${result.projectStats.totalLines.toLocaleString()}

### Languages
${Object.entries(result.projectStats.languages)
  .map(([lang, stats]) => `- **${lang.toUpperCase()}**: ${stats.files} files, ${stats.lines.toLocaleString()} lines`)
  .join('\n')}

## Code Quality

- **ESLint Errors**: ${result.lintResults.errors}
- **ESLint Warnings**: ${result.lintResults.warnings}

## Dependencies

- **Total Dependencies**: ${result.dependencies.total}
- **Outdated Packages**: ${result.dependencies.outdated}

---
*Report generated by rebuild-6.0 code analyzer*
`;

  // Write reports
  await fs.writeFile('code-analysis.json', JSON.stringify(result, null, 2));
  await fs.writeFile('code-analysis.md', report);
  
}

// Run if called directly
if (require.main === module) {
  generateReport().catch(console.error);
}

export { generateReport };